(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{309:function(t,e,a){"use strict";a.r(e);var c=a(14),i=Object(c.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("10.2 Git 内部原理 - Git 对象\nGit 对象\nGit 是一个内容寻址文件系统，听起来很酷。但这是什么意思呢？ 这意味着，Git 的核心部分是一个简单的键值对数据库（key-value data store）。 你可以向 Git 仓库中插入任意类型的内容，它会返回一个唯一的键，通过该键可以在任意时刻再次取回该内容。")]),t._v(" "),e("p",[t._v("可以通过底层命令 git hash-object 来演示上述效果——该命令可将任意数据保存于 .git/objects 目录（即 对象数据库），并返回指向该数据对象的唯一的键。")]),t._v(" "),e("p",[t._v("首先，我们需要初始化一个新的 Git 版本库，并确认 objects 目录为空：")]),t._v(" "),e("p",[t._v("$ git init test\nInitialized empty Git repository in /tmp/test/.git/\n$ cd test\n$ find .git/objects\n.git/objects\n.git/objects/info\n.git/objects/pack\n$ find .git/objects -type f\n可以看到 Git 对 objects 目录进行了初始化，并创建了 pack 和 info 子目录，但均为空。 接着，我们用 git hash-object 创建一个新的数据对象并将它手动存入你的新 Git 数据库中：")]),t._v(" "),e("p",[t._v("$ echo 'test content' | git hash-object -w --stdin\nd670460b4b4aece5915caf5c68d12f560a9fe3e4\n在这种最简单的形式中，git hash-object 会接受你传给它的东西，而它只会返回可以存储在 Git 仓库中的唯一键。 -w 选项会指示该命令不要只返回键，还要将该对象写入数据库中。 最后，--stdin 选项则指示该命令从标准输入读取内容；若不指定此选项，则须在命令尾部给出待存储文件的路径。")]),t._v(" "),e("p",[t._v("此命令输出一个长度为 40 个字符的校验和。 这是一个 SHA-1 哈希值——一个将待存储的数据外加一个头部信息（header）一起做 SHA-1 校验运算而得的校验和。后文会简要讨论该头部信息。 现在我们可以查看 Git 是如何存储数据的：")]),t._v(" "),e("p",[t._v("$ find .git/objects -type f\n.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4\n如果你再次查看 objects 目录，那么可以在其中找到一个与新内容对应的文件。 这就是开始时 Git 存储内容的方式——一个文件对应一条内容， 以该内容加上特定头部信息一起的 SHA-1 校验和为文件命名。 校验和的前两个字符用于命名子目录，余下的 38 个字符则用作文件名。")]),t._v(" "),e("p",[t._v("一旦你将内容存储在了对象数据库中，那么可以通过 cat-file 命令从 Git 那里取回数据。 这个命令简直就是一把剖析 Git 对象的瑞士军刀。 为 cat-file 指定 -p 选项可指示该命令自动判断内容的类型，并为我们显示大致的内容：")]),t._v(" "),e("p",[t._v("$ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4\ntest content\n至此，你已经掌握了如何向 Git 中存入内容，以及如何将它们取出。 我们同样可以将这些操作应用于文件中的内容。 例如，可以对一个文件进行简单的版本控制。 首先，创建一个新文件并将其内容存入数据库：")]),t._v(" "),e("p",[t._v("$ echo 'version 1' > test.txt\n$ git hash-object -w test.txt\n83baae61804e65cc73a7201a7252750c76066a30\n接着，向文件里写入新内容，并再次将其存入数据库：")]),t._v(" "),e("p",[t._v("$ echo 'version 2' > test.txt\n$ git hash-object -w test.txt\n1f7a7a472abf3dd9643fd615f6da379c4acb3e3a\n对象数据库记录下了该文件的两个不同版本，当然之前我们存入的第一条内容也还在：")]),t._v(" "),e("p",[t._v("$ find .git/objects -type f\n.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a\n.git/objects/83/baae61804e65cc73a7201a7252750c76066a30\n.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4\n现在可以在删掉 test.txt 的本地副本，然后用 Git 从对象数据库中取回它的第一个版本：")]),t._v(" "),e("p",[t._v("$ git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30 > test.txt\n$ cat test.txt\nversion 1\n或者第二个版本：")]),t._v(" "),e("p",[t._v("$ git cat-file -p 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a > test.txt\n$ cat test.txt\nversion 2\n然而，记住文件的每一个版本所对应的 SHA-1 值并不现实；另一个问题是，在这个（简单的版本控制）系统中，文件名并没有被保存——我们仅保存了文件的内容。 上述类型的对象我们称之为 数据对象（blob object）。 利用 git cat-file -t 命令，可以让 Git 告诉我们其内部存储的任何对象类型，只要给定该对象的 SHA-1 值：")]),t._v(" "),e("p",[t._v("$ git cat-file -t 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a\nblob\n树对象\n接下来要探讨的 Git 对象类型是树对象（tree object），它能解决文件名保存的问题，也允许我们将多个文件组织到一起。 Git 以一种类似于 UNIX 文件系统的方式存储内容，但作了些许简化。 所有内容均以树对象和数据对象的形式存储，其中树对象对应了 UNIX 中的目录项，数据对象则大致上对应了 inodes 或文件内容。 一个树对象包含了一条或多条树对象记录（tree entry），每条记录含有一个指向数据对象或者子树对象的 SHA-1 指针，以及相应的模式、类型、文件名信息。 例如，某项目当前对应的最新树对象可能是这样的：")]),t._v(" "),e("p",[t._v("$ git cat-file -p master^{tree}\n100644 blob a906cb2a4a904a152e80877d4088654daad0c859      README\n100644 blob 8f94139338f9404f26296befa88755fc2598c289      Rakefile\n040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0      lib\nmaster^{tree} 语法表示 master 分支上最新的提交所指向的树对象。 请注意，lib 子目录（所对应的那条树对象记录）并不是一个数据对象，而是一个指针，其指向的是另一个树对象：")]),t._v(" "),e("p",[t._v("$ git cat-file -p 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0\n100644 blob 47c6340d6459e05787f644c2447d2595f5d3a54b      simplegit.rb")])])}),[],!1,null,null,null);e.default=i.exports}}]);